# Example of Halide with Python and Rust interop

## TODO: Basic setup instructions

`pip install halide`

Activate venv. This requires `VIRTUAL_ENV` to be defined.
Halide headers are in `$VIRTUAL_ENV/lib/python3.13/site-packages/halide/include`

`brew install rustup && rustup-init`


## Run Halide generators to AOT compile some imaging pipelines

Halide generators are written in Python. Each *generates* a header and static library. We put them under `halide_generated`.

```bash
python src/add/add_generator.py -g add_generator -f add -e c_header,static_library -n add -o halide_generated target=host-debug-no_runtime

python src/demosaic/demosaic_generator.py -g demosaic_generator -f demosaic -e c_header,static_library -n demosaic -o halide_generated target=host-debug-no_runtime
```

Halide pipelines need a runtime. Generators can produce them. Use `gen_halide_runtime.py` to generate a Halide runtime for the host, also under `halide_generated`.

```bash
python src/halide_runtime/gen_halide_runtime.py -r host_debug_runtime -o halide_generated target=host-debug
```

## Use `cargo` to build (or run) the Rust code

`build.rs` uses `bindgen` to generate:

* `HalideRuntime.h -> $OUT/halide_runtime_bindings.rs`
* For each generator's header, `$OUT/${GENERATOR}_bindings.rs`

`build.rs` then links against:

* Each generator's `.a`
* `host_debug_runtime.a`

Build and run:

```
HL_TARGET=host-trace_stores cargo run
```

## How bindings work

There is more boilerplate than we'd like. While `halide_runtime_bindings.rs` is complex, `bindgen` generates
trivial bindings for each generator. Perhaps Halide can emit them directly.

For example, `add.h` looks like this:

```C
int add(struct halide_buffer_t *_input_buffer, struct halide_buffer_t *_output_buffer);
```

`add_bindings.rs` (produced by `bindgen`) looks like this:

```Rust
/* automatically generated by rust-bindgen 0.72.1 */

unsafe extern "C" {
    pub fn add(
        _input_buffer: *mut halide_buffer_t,
        _output_buffer: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
```

Because that's it, it needs to be textually inlined into a Rust module. See [src/add/include_bindings.rs](src/add/include_bindings.rs).

Finally, because `add` is a subdirectory, it needs `add.rs` in the parent (Rust conventions) to re-export `add`.

This can probably be simplified.
